<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GestureFlux-3D: Evolution | Interactive Particle Physics</title>
    <link rel="icon" type="image/png" href="favicon.png">

    <style>
        :root { --accent: #00f2ff; --bg: #020205; --ui-panel: rgba(10, 10, 20, 0.7); }

        body {
            margin: 0; background: var(--bg); color: #fff;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            overflow: hidden; user-select: none;
        }

        canvas { display: block; position: fixed; top: 0; left: 0; z-index: 1; }

        /* UI HUD */
        #hud {
            position: absolute; inset: 0; z-index: 10;
            pointer-events: none; padding: 40px;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .top-left { border-left: 3px solid var(--accent); padding-left: 20px; }
        
        h1 {
            margin: 0; font-weight: 200; letter-spacing: 15px;
            text-transform: uppercase; font-size: 2.2rem;
            text-shadow: 0 0 30px rgba(0, 242, 255, 0.4);
        }

        .status-box {
            margin-top: 15px; background: var(--ui-panel);
            backdrop-filter: blur(15px); padding: 20px;
            border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);
            display: inline-block; min-width: 300px; pointer-events: auto;
        }

        #gesture-hint { font-size: 0.85rem; letter-spacing: 1px; color: var(--accent); font-weight: 600; text-transform: uppercase; }
        #description { font-size: 0.75rem; opacity: 0.5; margin-top: 10px; line-height: 1.5; }

        /* Webcam HUD */
        #webcam-monitor {
            position: absolute; right: 40px; bottom: 40px;
            width: 220px; height: 165px; border-radius: 12px;
            overflow: hidden; border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            transform: scaleX(-1); z-index: 11; opacity: 0.7; transition: 0.3s;
        }
        #webcam-monitor:hover { opacity: 1; transform: scaleX(-1) scale(1.05); }
        #webcam { width: 100%; height: 100%; object-fit: cover; }

        /* Fullscreen Loader */
        #loader {
            position: fixed; inset: 0; background: #000; z-index: 1000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 1s ease;
        }
        .loading-text { letter-spacing: 10px; font-size: 12px; opacity: 0.6; margin-top: 20px; }
        .progress-bar { width: 150px; height: 1px; background: rgba(255,255,255,0.1); position: relative; margin-top: 15px; }
        .progress-fill { position: absolute; left: 0; top: 0; height: 100%; background: var(--accent); width: 0%; transition: width 0.3s; }

        /* Control Panel customization */
        .lil-gui.root { top: 40px !important; right: 40px !important; z-index: 100; }

        /* Mobile Responsive Styles */
@media (max-width: 768px) {
    #hud { padding: 20px; }
    
    h1 { 
        font-size: 1.5rem; 
        letter-spacing: 8px; 
    }
    
    .status-box { 
        min-width: auto; 
        padding: 15px; 
        margin-top: 10px; 
    }
    
    #gesture-hint { font-size: 0.75rem; }
    #description { font-size: 0.7rem; }
    
    #webcam-monitor { 
        width: 120px; 
        height: 90px; 
        right: 20px; 
        bottom: 20px; 
    }
    
    .lil-gui.root { 
        top: 20px !important; 
        right: 20px !important; 
        transform: scale(0.8); 
        transform-origin: top right; 
    }
}

@media (max-width: 480px) {
    #hud { padding: 15px; }
    
    h1 { 
        font-size: 1.2rem; 
        letter-spacing: 4px; 
    }
    
    .status-box { padding: 12px; }
    
    #webcam-monitor { 
        width: 100px; 
        height: 75px; 
        right: 15px; 
        bottom: 15px; 
    }
    
    .lil-gui.root { 
        transform: scale(0.7); 
    }
}

@media (max-width: 320px) {
    #hud { padding: 10px; }
    
    h1 { 
        font-size: 1rem; 
        letter-spacing: 2px; 
    }
    
    .status-box { 
        padding: 10px; 
        font-size: 0.8rem; 
    }
    
    #webcam-monitor { 
        width: 80px; 
        height: 60px; 
        right: 10px; 
        bottom: 10px; 
    }
}

/* Landscape mobile orientation */
@media (max-height: 500px) and (orientation: landscape) {
    #hud { padding: 10px; }
    
    h1 { font-size: 1rem; }
    
    .status-box { 
        padding: 8px; 
        margin-top: 5px; 
    }
    
    #webcam-monitor { 
        width: 80px; 
        height: 60px; 
        right: 10px; 
        bottom: 10px; 
    }
}
    </style>
</head>

<body>

<div id="loader">
    <h1 style="font-size: 3rem;">GestureFlux-3D</h1>
    <div class="progress-bar"><div id="load-progress" class="progress-fill"></div></div>
    <div class="loading-text">SYNCING GEOMETRIES</div>
</div>

<div id="hud">
    <div class="top-left">
        <h1>GestureFlux-3D</h1>
        <div class="status-box">
            <div id="gesture-hint">Initializing Optical Neural Link...</div>
            <div id="description">Show your hand to the camera. Pinch to compress space, open your hand to expand it.</div>
        </div>
    </div>
</div>

<div id="webcam-monitor">
    <video id="webcam" autoplay playsinline></video>
</div>

<!-- Dependency Mapping -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from "three";
import { GUI } from "three/addons/libs/lil-gui.module.min.js";
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

/* -----------------------------------------------------------
   CONFIG & STATE
----------------------------------------------------------- */
const P_COUNT = 20000;
const state = {
    template: 'Singularity',
    color: '#00f2ff',
    particleSize: 0.12,
    morphSpeed: 0.07,
    rotationSpeed: 0.5,
    exposure: 1.0,
    bloomStrength: 1.2,
    handTension: 1.0 // This tracks gesture expansion
};

let scene, camera, renderer, points, geometry, material, composer;
let video, handLandmarker, lastVideoTime = -1;
const targets = new Float32Array(P_COUNT * 3);

/* -----------------------------------------------------------
   12 IMPRESSIVE PATTERN GENERATORS
----------------------------------------------------------- */
const Patterns = {
        Singularity(i) {
        const r = 4 + Math.pow(Math.random(), 3) * 25, a = Math.random() * Math.PI * 2;
        return new THREE.Vector3(Math.cos(a)*r, (1/r)*(Math.random()-0.5)*15, Math.sin(a)*r);
    },
        CosmicPalace(i) {
        const p = new THREE.Vector3();
        
        // Define Partition Sizes
        const pillarsLimit = P_COUNT * 0.3;     // 30% Structural Pillars
        const roomsLimit = P_COUNT * 0.7;       // 40% Memory Chambers
        const corridorLimit = P_COUNT * 0.9;    // 20% Connective Bridges
        // 10% Residual Memory Dust

        if (i < pillarsLimit) {
            // THE PILLARS (Columns of Light)
            const pillarIdx = i % 12; // 12 columns
            const height = (Math.random() - 0.5) * 40;
            const radius = 0.5 + Math.random() * 1.5;
            const angle = (pillarIdx / 12) * Math.PI * 2;
            const px = Math.cos(angle) * (15 + pillarIdx);
            const pz = Math.sin(angle) * (15 + pillarIdx);
            
            p.set(px + (Math.random() - 0.5) * radius, height, pz + (Math.random() - 0.5) * radius);

        } else if (i < roomsLimit) {
            // THE CHAMBERS (Holographic Rooms)
            const roomId = i % 6; // 6 main rooms
            if (!roomCenters[roomId]) {
                roomCenters[roomId] = new THREE.Vector3((Math.random()-0.5)*35, (Math.random()-0.5)*25, (Math.random()-0.5)*20);
            }
            const center = roomCenters[roomId];
            const volume = 8;
            p.set(
                center.x + (Math.random()-0.5)*volume, 
                center.y + (Math.random()-0.5)*volume, 
                center.z + (Math.random()-0.5)*volume
            );

        } else if (i < corridorLimit) {
            // CONNECTIVE BRIDGES (Data Paths between rooms)
            const r1 = i % 6;
            const r2 = (i + 1) % 6;
            const alpha = Math.random(); // Position along the path
            const start = roomCenters[r1];
            const end = roomCenters[r2];
            
            // Linear interpolation with wave distortion
            const pathX = start.x + (end.x - start.x) * alpha;
            const pathY = start.y + (end.y - start.y) * alpha;
            const pathZ = start.z + (end.z - start.z) * alpha;
            const noise = Math.sin(alpha * 15 + Date.now() * 0.002) * 1.5;
            p.set(pathX + noise, pathY + noise, pathZ + noise);

        } else {
            // COSMIC DUST (Deep Ambient Context)
            const range = 50;
            p.set((Math.random()-0.5)*range, (Math.random()-0.5)*range, (Math.random()-0.5)*range);
        }
        return p;
    },
    DNA(i) {
        const spiral = i % 2 === 0 ? 1 : -1;
        const y = (i / P_COUNT) * 30 - 15;
        const angle = y * 1.2 + (spiral === 1 ? 0 : Math.PI);
        const r = 6;
        if (i % 30 === 0) return new THREE.Vector3((Math.random()-0.5)*r*2, y, 0); // Bridges
        return new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
    },
    HyperSphere(i) {
        const layer = Math.floor((i / P_COUNT) * 4);
        const r = (layer + 1) * 4;
        const u = Math.random(), v = Math.random();
        const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
        return new THREE.Vector3(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
    },
    Mobius(i) {
        const u = (i / P_COUNT) * Math.PI * 2;
        const v = (Math.random() - 0.5) * 5;
        const a = 12;
        return new THREE.Vector3(
            (a + v * Math.cos(u / 2)) * Math.cos(u),
            (a + v * Math.cos(u / 2)) * Math.sin(u),
            v * Math.sin(u / 2)
        );
    },
    Vortex(i) {
        const r = (i / P_COUNT) * 15;
        const angle = i * 0.05;
        return new THREE.Vector3(Math.cos(angle)*r, (Math.random()-0.5)*r, Math.sin(angle)*r);
    },
    DigitalIris(i) {
        const ring = i % 10; 
        const r = 2 + (ring * 1.2) + Math.random() * 0.5;
        const angle = (i / P_COUNT) * Math.PI * 150;
        const x = Math.cos(angle) * r;
        const y = Math.sin(angle) * r;
        // Central depth logic
        const z = (ring < 2) ? (Math.random() - 0.5) * 5 : (Math.random() - 0.5);
        return new THREE.Vector3(x, y, z);
    },
    Galaxy(i) {
        const r = Math.pow(Math.random(), 0.5) * 18;
        const angle = r * 0.8 + (i % 3) * (Math.PI * 2 / 3);
        const noise = (Math.random()-0.5) * 2;
        return new THREE.Vector3(Math.cos(angle)*r + noise, (Math.random()-0.5)*1.5, Math.sin(angle)*r + noise);
    },
    Lotus(i) {
        const t = Math.random() * Math.PI * 2;
        const p = Math.random() * Math.PI;
        const r = 8 * (1 + 0.3 * Math.sin(6 * t)) * Math.sin(p);
        return new THREE.Vector3(r * Math.sin(p) * Math.cos(t), r * Math.cos(p), r * Math.sin(p) * Math.sin(t));
    },
    Starfield(i) {
        return new THREE.Vector3((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*50);
    },
    Cylinder(i) {
        const h = (Math.random()-0.5)*20;
        const a = Math.random() * Math.PI * 2;
        const r = 8;
        return new THREE.Vector3(Math.cos(a)*r, h, Math.sin(a)*r);
    },
    Heart(i) {
        const t = Math.random() * Math.PI * 2;
        const x = 16 * Math.pow(Math.sin(t), 3);
        const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
        return new THREE.Vector3(x * 0.45, y * 0.45, (Math.random() - 0.5) * 5);
    },
        /* 19. EVENT HORIZON CHOIR (The Harmonic Well) */
    EventHorizonChoir(i) {
        const p = new THREE.Vector3();
        
        // Distribution: 15% Divine Core, 85% Resonating Rings
        const isCore = i < P_COUNT * 0.15;

        if (isCore) {
            // THE DIVINE CORE: High-density light source
            const u = Math.random(), v = Math.random();
            const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
            const r = Math.pow(Math.random(), 2) * 6; // Concentrated center
            p.set(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );
        } else {
            // THE HARMONIC RINGS: Concentric energy fields
            const ringCount = 10;
            const ringIndex = i % ringCount; 
            
            // Base ring math
            const radius = 10 + (ringIndex * 2.5);
            const angle = (i / P_COUNT) * Math.PI * 150; // Densely packed along the perimeter
            
            const bx = Math.cos(angle) * radius;
            const bz = Math.sin(angle) * radius;

            // WAVE OSCILLATION: The "Singing" effect
            // We use the timestamp to create movement, and ringIndex to phase-shift the harmony
            const time = Date.now() * 0.002;
            const frequency = 3 + (ringIndex * 0.5); // Each ring "sings" at a higher pitch
            
            // Vertical sound wave oscillation
            const waveY = Math.sin(angle * frequency + time + ringIndex) * 2.0;

            // Ripple distortion (Radial Pulse)
            const ripple = Math.cos(angle * 2 + time) * 0.5;

            p.set(
                bx + (bx * ripple * 0.1), 
                waveY, 
                bz + (bz * ripple * 0.1)
            );
        }

        return p;
    },
    CelestialGate(i) {
        const p = new THREE.Vector3();
        const rand = Math.random();
        
        if (i < P_COUNT * 0.4) {
            // 40%: The Core Vortex (Hyper-spiral)
            const ratio = i / (P_COUNT * 0.4);
            const angle = ratio * Math.PI * 40;
            const r = Math.pow(ratio, 0.5) * 8;
            const depth = (1 - ratio) * 15;
            p.set(Math.cos(angle) * r, Math.sin(angle) * r, depth - 7.5);

        } else if (i < P_COUNT * 0.8) {
            // 40%: Concentric Event Horizon Rings
            const ringCount = 4;
            const ringIndex = i % ringCount;
            const radius = 10 + ringIndex * 3;
            const angle = Math.random() * Math.PI * 2;
            const thickness = 0.5;
            p.set(
                Math.cos(angle) * (radius + (Math.random()-0.5) * thickness),
                Math.sin(angle) * (radius + (Math.random()-0.5) * thickness),
                (Math.random()-0.5) * 1.5
            );
        } else {
            // 20%: Floating Glyph Arcs
            const segment = i % 5;
            const radius = 22 + segment;
            const startAngle = (segment * (Math.PI * 2) / 5) + (Date.now() * 0.0001);
            const arcLength = 0.8;
            const angle = startAngle + (Math.random() * arcLength);
            p.set(Math.cos(angle)*radius, Math.sin(angle)*radius, (Math.random()-0.5) * 4);
        }
        return p;
    },
    /* 15. NEURAL BLOOM (The AI Mind) */
    NeuralBloom(i) {
        const p = new THREE.Vector3();
        
        // Split particles: 20% Nucleus (Core), 80% Axons (Neurons)
        const isNucleus = i < P_COUNT * 0.2;

        if (isNucleus) {
            // THE NUCLEUS: A hyper-dense processing core
            const u = Math.random(), v = Math.random();
            const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
            // Core logic: Shimmering sphere
            const r = Math.pow(Math.random(), 2) * 4; 
            p.set(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi)
            );
        } else {
            // THE AXONS: Branching neuron tendrils
            const branchId = i % 12; // Creates 12 main nerve fibers
            const growthFactor = (i / P_COUNT); // How far along the branch the particle is
            
            // Branch shape math: Use golden-angle spirals and sine waves
            const spiralRadius = growthFactor * 22;
            const swirl = growthFactor * 10.0;
            const angle = (branchId * Math.PI * 2 / 12) + swirl;
            
            const x = Math.cos(angle) * spiralRadius;
            const y = Math.sin(angle) * spiralRadius;
            const z = Math.sin(growthFactor * 15 + branchId) * 3;

            // SYNAPTIC PULSE: Move some particles along the path
            if (i % 15 === 0) {
                // Synapse travel logic based on real-time
                const flow = (Date.now() * 0.0015 + branchId) % 1.0;
                const flowR = flow * 22;
                const flowA = (branchId * Math.PI * 2 / 12) + (flow * 10.0);
                p.set(
                    Math.cos(flowA) * flowR,
                    Math.sin(flowA) * flowR,
                    Math.sin(flow * 15 + branchId) * 4 // Slightly offset height
                );
            } else {
                p.set(x, y, z);
            }

            // Micro-tendril noise
            const jitter = (Math.random() - 0.5) * 1.2;
            p.x += jitter; p.y += jitter; p.z += jitter;
        }

        return p;
    },
    /* 16. GRAVITY WELL (The Event Horizon) */
    GravityWell(i) {
        const p = new THREE.Vector3();
        
        // Split: 85% Accretion Disk, 15% Hawking Radiation/Jets
        const isDisk = i < P_COUNT * 0.85;

        if (isDisk) {
            // THE ACCRETION DISK
            // Inverse distribution: More particles closer to the center
            const distFactor = Math.pow(Math.random(), 2); 
            const minBound = 5;  // The 'Shadow' radius
            const maxBound = 30; // Outer disk reach
            const r = minBound + distFactor * (maxBound - minBound);

            // Spiral Physics: inner particles spin faster (Keplerian-ish)
            const swirlSpeed = 8.0 / (distFactor + 0.2);
            const theta = Math.random() * Math.PI * 2 + swirlSpeed;

            // Frame Dragging: The disk is thin at edges, but warps/thickens at core
            const thickness = (1.0 - distFactor) * 3.5;
            const z = (Math.random() - 0.5) * thickness;

            p.set(
                Math.cos(theta) * r,
                Math.sin(theta) * r,
                z
            );
        } else {
            // RELATIVISTIC JETS
            // Vertical pillars of light escaping the well
            const verticalReach = 40;
            const z = (Math.random() - 0.5) * verticalReach;
            
            // The jet stays very tight near the axis
            const jetRadius = 0.2 + (Math.abs(z) * 0.05);
            const theta = Math.random() * Math.PI * 2;
            
            p.set(
                Math.cos(theta) * jetRadius,
                Math.sin(theta) * jetRadius,
                z
            );
        }

        return p;
    },
    /* 17. ORBITAL CITY (The Space Metropolis) */
    OrbitalCity(i) {
        const p = new THREE.Vector3();
        
        // Distribution: 15% Core Reactor, 60% Buildings, 25% Traffic Veins
        const coreLimit = P_COUNT * 0.15;
        const buildingLimit = P_COUNT * 0.75;

        if (i < coreLimit) {
            // THE POWER REACTOR: Dense glowing sun at the city center
            const r = Math.pow(Math.random(), 2) * 4;
            const t = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            p.set(
                r * Math.sin(phi) * Math.cos(t),
                r * Math.sin(phi) * Math.sin(t),
                r * Math.cos(phi)
            );
        } else if (i < buildingLimit) {
            // THE BUILDINGS: Monolithic blocks floating in organized shells
            const blockId = i % 40; // Number of skyscraper monoliths
            const layer = blockId % 3; // Inner, middle, or outer city ring
            
            // Positioning the base of the skyscraper
            const ringRadius = 10 + layer * 6;
            const orbitAngle = (blockId / 40) * Math.PI * 2;
            const bx = Math.cos(orbitAngle) * ringRadius;
            const bz = Math.sin(orbitAngle) * ringRadius;
            
            // Generating the vertical prism shape
            const particlesPerBlock = (P_COUNT * 0.6) / 40;
            const heightIndex = i % particlesPerBlock;
            const progress = heightIndex / particlesPerBlock; // 0 to 1 along the building height
            
            const buildingH = 5 + (blockId % 7); // Random heights
            const width = 1.2;
            
            p.set(
                bx + (Math.random() - 0.5) * width,
                (progress * buildingH) - (buildingH / 2),
                bz + (Math.random() - 0.5) * width
            );
        } else {
            // TRAFFIC VEINS: Fast-moving scan-lines/transport streams
            const ringId = i % 3;
            const radius = 13 + ringId * 6;
            const flowSpeed = Date.now() * 0.002;
            const angle = (i * 0.01) + flowSpeed; 
            
            // Add a "dash" effect (some particles skip segments)
            const gap = Math.sin(i) > 0.5 ? radius : 0;
            
            p.set(
                Math.cos(angle) * radius,
                (Math.random() - 0.5) * 0.3, // Flat traffic plane
                Math.sin(angle) * radius
            );
        }

        return p;
    }
};

/* -----------------------------------------------------------
   CORE ENGINE
----------------------------------------------------------- */
async function init() {
    // 1. Scene Setup
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
    camera.position.z = 40;

    renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // 2. Post-Processing (Quantum Glow)
    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), state.bloomStrength, 0.4, 0.1);
    composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);
    composer.addPass(new OutputPass());

    // 3. Particles
    geometry = new THREE.BufferGeometry();
    geometry.setAttribute("position", new THREE.BufferAttribute(new Float32Array(P_COUNT * 3), 3));

    material = new THREE.PointsMaterial({
        size: state.particleSize,
        color: state.color,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        map: createPointTexture(),
        opacity: 0.8
    });

    points = new THREE.Points(geometry, material);
    scene.add(points);

    // 4. GUI & Input
    updateTemplate(state.template);
    initGUI();
    await initMediaPipe();

    // Fade Out Loader
    document.getElementById("load-progress").style.width = "100%";
    setTimeout(() => {
        document.getElementById("loader").style.opacity = "0";
        setTimeout(() => document.getElementById("loader").remove(), 1000);
    }, 500);

    animate();
}

function createPointTexture() {
    const canvas = document.createElement("canvas");
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext("2d");
    const grad = ctx.createRadialGradient(32,32,0, 32,32,32);
    grad.addColorStop(0, 'rgba(255,255,255,1)');
    grad.addColorStop(0.2, 'rgba(255,255,255,0.6)');
    grad.addColorStop(0.5, 'rgba(255,255,255,0.05)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,64,64);
    return new THREE.CanvasTexture(canvas);
}

function updateTemplate(name) {
    const gen = Patterns[name];
    for (let i = 0; i < P_COUNT; i++) {
        const v = gen(i);
        targets[i * 3] = v.x;
        targets[i * 3 + 1] = v.y;
        targets[i * 3 + 2] = v.z;
    }
}

async function initMediaPipe() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video = document.getElementById("webcam");
        video.srcObject = stream;

        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: { 
                modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                delegate: "GPU" 
            },
            runningMode: "VIDEO", numHands: 1
        });
        document.getElementById("load-progress").style.width = "80%";
    } catch (e) {
        document.getElementById("gesture-hint").innerText = "Vision System Offline";
        document.getElementById("gesture-hint").style.color = "#ff4444";
    }
}

function handleGestures(res) {
    const hint = document.getElementById("gesture-hint");
    if (res.landmarks && res.landmarks.length > 0) {
        const hand = res.landmarks[0];
        // Calculate Distance between Thumb Tip (4) and Index Tip (8)
        const d = Math.sqrt(
            Math.pow(hand[4].x - hand[8].x, 2) + 
            Math.pow(hand[4].y - hand[8].y, 2)
        );
        // Map 0.05 - 0.35 range to 0.4x - 4.0x scale
        const targetTension = THREE.MathUtils.mapLinear(d, 0.05, 0.35, 0.4, 3.5);
        state.handTension = THREE.MathUtils.lerp(state.handTension, targetTension, 0.2);
        
        hint.innerText = d > 0.15 ? "Pulse Detected: Expanding" : "Pulse Detected: Compressing";
        hint.style.color = "var(--accent)";
    } else {
        state.handTension = THREE.MathUtils.lerp(state.handTension, 1.0, 0.05);
        hint.innerText = "Scanning for Hands...";
        hint.style.color = "rgba(255,255,255,0.3)";
    }
}

function animate() {
    requestAnimationFrame(animate);

    if (video && handLandmarker && video.readyState >= 2 && video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;
        const res = handLandmarker.detectForVideo(video, performance.now());
        handleGestures(res);
    }

    const pos = geometry.attributes.position.array;
    for (let i = 0; i < P_COUNT; i++) {
        const i3 = i * 3;
        // Morph + Hand Interaction
        pos[i3] += (targets[i3] * state.handTension - pos[i3]) * state.morphSpeed;
        pos[i3+1] += (targets[i3+1] * state.handTension - pos[i3+1]) * state.morphSpeed;
        pos[i3+2] += (targets[i3+2] * state.handTension - pos[i3+2]) * state.morphSpeed;
    }
    geometry.attributes.position.needsUpdate = true;

    points.rotation.y += 0.003 * state.rotationSpeed;
    points.rotation.x += 0.001 * state.rotationSpeed;

    composer.render();
}

function initGUI() {
    const gui = new GUI();
    gui.add(state, "template", Object.keys(Patterns)).name("Geometry").onChange(updateTemplate);
    gui.addColor(state, "color").name("Quantum Color").onChange(c => material.color.set(c));
    gui.add(state, "particleSize", 0.01, 0.5).name("Point Scale");
    gui.add(state, "morphSpeed", 0.01, 0.2).name("Elasticity");
    
    const fx = gui.addFolder("Glow Engine");
    fx.add(state, "bloomStrength", 0, 3).name("Brightness").onChange(v => composer.passes[1].strength = v);
    fx.add(state, "rotationSpeed", 0, 2).name("Orbit");
}

addEventListener("resize", () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    composer.setSize(innerWidth, innerHeight);
});

init();
</script>
</body>
</html>